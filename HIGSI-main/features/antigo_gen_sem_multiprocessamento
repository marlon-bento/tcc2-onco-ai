import os
import time  
from datetime import datetime, timedelta 
import locale
import torch
import cv2
import pandas as pd
from tqdm import tqdm
from torch_geometric.data import Data
from dotenv import load_dotenv
import os
from prof.grap_utils_new import RAG


from decouple import config

# ==============================================================================
# --- PAINEL DE CONTROLE DO EXPERIMENTO ---
# ==============================================================================
ARQUIVO_MANIFEST = config("MANIFEST_FILE_PATH")
PASTA_IMAGENS = config("DATASET_IMAGES_PATH")
PASTA_FEATURES = config("PASTA_FEATURES")

if not ARQUIVO_MANIFEST or not PASTA_IMAGENS or not PASTA_FEATURES:
    raise ValueError("ERRO: Verifique as vari√°veis de caminho no arquivo .env.")

LISTA_MAX_DIM = [1024]
LISTA_N_NODES = [15]
#1024
# --- FUN√á√ÉO AUXILIAR PARA FORMATAR O TEMPO ---
def formatar_tempo(segundos):
    """Converte segundos para um formato leg√≠vel (h, m, s)."""
    horas = int(segundos // 3600)
    minutos = int((segundos % 3600) // 60)
    segundos = int(segundos % 60)
    if horas > 0:
        return f"{horas}h, {minutos}m e {segundos}s"
    elif minutos > 0:
        return f"{minutos}m e {segundos}s"
    else:
        return f"{segundos}s"

# ==============================================================================
def pre_processar_imagem(caminho_final_encontrado, max_dim):
    img_color = cv2.imread(caminho_final_encontrado)
    if img_color is None: return None
    img_processada = img_color.copy()
    
    if max_dim is not None:
        h, w = img_processada.shape[:2]
        if h > max_dim or w > max_dim:
            scale = max_dim / max(h, w)
            img_processada = cv2.resize(img_processada, (int(w*scale), int(h*scale)), interpolation=cv2.INTER_AREA)
    
    img_rgb = cv2.cvtColor(img_processada, cv2.COLOR_BGR2RGB)
    # --- APLICA√á√ÉO DE CLAHE NA IMAGEM COLORIDA ---
    # a. Converte de RGB para o espa√ßo de cor LAB
    lab = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2LAB)
    
    # b. Separa os canais (L=Luminosidade, a, b=Cor)
    l_channel, a_channel, b_channel = cv2.split(lab)
    
    # c. Cria o objeto CLAHE e aplica APENAS no canal L
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
    l_channel_clahe = clahe.apply(l_channel)
    
    # d. Junta os canais novamente
    lab_clahe = cv2.merge((l_channel_clahe, a_channel, b_channel))
    
    # e. Converte de volta para RGB
    img_rgb_final = cv2.cvtColor(lab_clahe, cv2.COLOR_LAB2RGB)
    # -----------------------------------------------
    
    return img_rgb_final
# --- BLOCO DE EXECU√á√ÉO ---
def gerar_features():
    # --- 2. DEFINIR O LOCALE PARA PORTUGU√äS DO BRASIL ---
    # Isso garante que nomes de meses e dias da semana saiam em portugu√™s.
    try:
        locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
    except locale.Error:
        print("Aviso: O locale 'pt_BR.UTF-8' n√£o est√° instalado. Usando o padr√£o do sistema.")
    # --------------------------------------------------------
    df_manifest = pd.read_csv(ARQUIVO_MANIFEST)
    print(f"Manifesto '{ARQUIVO_MANIFEST}' carregado com {len(df_manifest)} imagens.")

    # --- L√ìGICA DE PREVIS√ÉO DE TEMPO ---
    print("\nCalculando previs√£o de tempo...")
    
    # 1. Identifica quais experimentos ainda precisam ser rodados
    experimentos_pendentes = []
    for max_dim in LISTA_MAX_DIM:
        for n_nodes in LISTA_N_NODES:
            dim_folder_name = "original" if max_dim is None else str(max_dim)
            output_file_path = os.path.join(PASTA_FEATURES, dim_folder_name, f'{n_nodes}.pt')
            if not os.path.exists(output_file_path):
                experimentos_pendentes.append({'max_dim': max_dim, 'n_nodes': n_nodes})

    if not experimentos_pendentes:
        print("üéâ Todos os experimentos j√° foram conclu√≠dos!")
    else:
        n_imagens_calibracao = min(5, len(df_manifest))
        param_calibracao = experimentos_pendentes[-1]
        
        tempo_inicio_calibracao = time.time()
        
        for index, row in df_manifest.head(n_imagens_calibracao).iterrows():
            caminho_relativo = row['image file path']
            caminho_final_encontrado = None
            partes_caminho = caminho_relativo.split('/')
            if len(partes_caminho) > 1:
                nome_pasta = partes_caminho[-2]
                pasta_do_exame = os.path.join(PASTA_IMAGENS, nome_pasta)
                if os.path.isdir(pasta_do_exame):
                    arquivos = [f for f in os.listdir(pasta_do_exame) if f.lower().endswith(('.jpeg', '.jpg', '.png'))]
                    if arquivos:
                        caminho_final_encontrado = os.path.join(pasta_do_exame, arquivos[0])

            if caminho_final_encontrado:
                img_processada = pre_processar_imagem(caminho_final_encontrado, max_dim)
                if img_processada is None: continue

                RAG(img_processada, n_nodes=param_calibracao['n_nodes'])

        tempo_fim_calibracao = time.time()
        
        tempo_por_imagem = (tempo_fim_calibracao - tempo_inicio_calibracao) / n_imagens_calibracao
        total_imagens_a_processar = len(df_manifest) * len(experimentos_pendentes)
        tempo_total_estimado_segundos = tempo_por_imagem * total_imagens_a_processar
        
        agora = datetime.now()
        previsao_termino = agora + timedelta(seconds=tempo_total_estimado_segundos)
        
        print(f"\nTempo m√©dio por imagem (calibrado): {tempo_por_imagem:.2f} segundos.")
        print(f"Total de imagens a processar: {total_imagens_a_processar} ({len(experimentos_pendentes)} experimentos).")
        print(f"üïí Dura√ß√£o total estimada: aproximadamente {formatar_tempo(tempo_total_estimado_segundos)}")
        print(f"üóìÔ∏è  Previs√£o de t√©rmino: {previsao_termino.strftime('%A, %d de %B de %Y √†s %H:%M')}")

    # --- Loop principal de extra√ß√£o ---
    for max_dim in LISTA_MAX_DIM:
        for n_nodes in LISTA_N_NODES:
            dim_folder_name = "original" if max_dim is None else str(max_dim)
            output_folder = os.path.join(PASTA_FEATURES, dim_folder_name)
            output_file_path = os.path.join(output_folder, f'{n_nodes}.pt')

            print("\n" + "="*50)
            print(f"Iniciando experimento: Tamanho Imagem = {dim_folder_name}, N√≥s = {n_nodes}")
            
            if os.path.exists(output_file_path):
                print(f"Resultado j√° existe. Pulando.")
                continue

            lista_grafos_atual = []
            
            for index, row in tqdm(df_manifest.iterrows(), total=len(df_manifest), desc=f"Processando {dim_folder_name}/{n_nodes}"):
                caminho_relativo = row['image file path']
                caminho_final_encontrado = None
                partes_caminho = caminho_relativo.split('/')
                if len(partes_caminho) > 1:
                    nome_pasta = partes_caminho[-2]
                    pasta_do_exame = os.path.join(PASTA_IMAGENS, nome_pasta)
                    if os.path.isdir(pasta_do_exame):
                        arquivos = [f for f in os.listdir(pasta_do_exame) if f.lower().endswith(('.jpeg', '.jpg', '.png'))]
                        if arquivos:
                            caminho_final_encontrado = os.path.join(pasta_do_exame, arquivos[0])

                if caminho_final_encontrado:
                    img_processada = pre_processar_imagem(caminho_final_encontrado, max_dim)
                    if img_processada is None: continue
                    
                    # 2. Agora, passa a imagem colorida e com contraste melhorado para o RAG
                    h_feat, edges, edge_feat, _, _ = RAG(img_processada, n_nodes=n_nodes)
                    # informa√ß√µes que v√£o ser salvas no grafo
                    lista_grafos_atual.append(Data(
                        x=torch.tensor(h_feat, dtype=torch.float), edge_index=torch.tensor(edges, dtype=torch.long),
                        edge_attr=torch.tensor(edge_feat, dtype=torch.float), y=torch.tensor([row['label']], dtype=torch.long),
                        source=row['pathology'], image_file_path=row['image file path']
                    ))

            if lista_grafos_atual:
                os.makedirs(output_folder, exist_ok=True)
                # torch.save(lista_grafos_atual, output_file_path)
                # nova vers√£o mudou o comportamento padr√£o do torch.save, ent√£o for√ßando o padr√£o antigo
                torch.save(lista_grafos_atual, output_file_path, _use_new_zipfile_serialization=False)
                print(f"SUCESSO: {len(lista_grafos_atual)} grafos salvos em '{output_file_path}'")
            else:
                print("AVISO: Nenhum grafo foi gerado para esta configura√ß√£o.")

    print("\n" + "="*50)
    print("Todos os experimentos foram conclu√≠dos!")